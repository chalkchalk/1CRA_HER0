// -------------------------------------------------------------------------------
// THIS FILE IS ORIGINALLY GENERATED BY THE DESIGNER.
// YOU ARE ONLY ALLOWED TO MODIFY CODE BETWEEN '///<<< BEGIN' AND '///<<< END'.
// PLEASE MODIFY AND REGENERETE IT IN THE DESIGNER FOR CLASS/MEMBERS/METHODS, ETC.
// -------------------------------------------------------------------------------

#include "Robot.h"

///<<< BEGIN WRITING YOUR CODE FILE_INIT
#include <chrono>
#include <sys/time.h>
#include <thread>
#include "hero_map/hero_map.h"
#include "hero_math/math.h"
#include "tf/tf.h"
#include <ros/package.h>

///<<< END WRITING YOUR CODE

namespace hero_decision
{
///<<< BEGIN WRITING YOUR CODE NAMESPACE_INIT

///<<< END WRITING YOUR CODE

	Robot::Robot()
	{
    ammo = 0;
    combat_effective_num = 0;
    combat_effectiveness = 0;
    health = 0;
///<<< BEGIN WRITING YOUR CODE CONSTRUCTOR

///<<< END WRITING YOUR CODE
	}

	Robot::~Robot()
	{
///<<< BEGIN WRITING YOUR CODE DESTRUCTOR

///<<< END WRITING YOUR CODE
	}

	behaviac::EBTStatus Robot::EngageRobot(behaviac::string robot_name)
	{
///<<< BEGIN WRITING YOUR CODE EngageRobot
    ROS_INFO("Engaging enemy");
    AttackRobot(0,0);
    AttackRobot(1,0);
    //if(FindRobotPosition(enemy_name_[0]).health == 0)
      return behaviac::BT_SUCCESS;
   // else
   //   return behaviac::BT_RUNNING;
///<<< END WRITING YOUR CODE
	}

  void Robot::Flee()
  {
  ///<<< BEGIN WRITING YOUR CODE Flee
  FleeBehaviour(0);
  FleeBehaviour(1);
  ROS_INFO("%s:flee",color_.c_str());
  ///<<< END WRITING YOUR CODE
  }

  behaviac::EBTStatus Robot::GoGetBuff()
	{
///<<< BEGIN WRITING YOUR CODE GoGetBuff


    if(buffInfo_.activated[GetBuffRFIDNum(FRIENDLY_AMMO)])
      return behaviac::BT_SUCCESS;
    else
    {
      ROS_INFO("%s:Go Get buff",color_.c_str());
      GoGetBuff(0 ,GetBuffRFIDNum(FRIENDLY_AMMO));
      GoGetBuff(1 ,GetBuffRFIDNum(FRIENDLY_AMMO));
      return behaviac::BT_RUNNING;
    }
///<<< END WRITING YOUR CODE
	}

	behaviac::EBTStatus Robot::WaitForGameStart()
	{
///<<< BEGIN WRITING YOUR CODE WaitForGameStart

    if(gameStatus_.game_status == gameStatus_.ROUND)
    {
      //ROS_INFO("%s: game start!",color_.c_str());
       return behaviac::BT_SUCCESS;

    }
    else
    {
      ROS_INFO("%s: Waiting for game start...",color_.c_str());
      return behaviac::BT_RUNNING;
    }
///<<< END WRITING YOUR CODE
	}

///<<< BEGIN WRITING YOUR CODE NAMESPACE_UNINIT


  void Robot::SetColor(std::string color)
  {
    color_ = color;
    Init();
  }

  void Robot::Init()
  {
    if(color_ == "blue")
    {
      friendly_name_[0] = "robot_0";
      friendly_name_[1] = "robot_1";
      enemy_name_[0] = "robot_2";
      enemy_name_[1] = "robot_3";
    }
    else if(color_ == "red")
    {
      friendly_name_[0] = "robot_2";
      friendly_name_[1] = "robot_3";
      enemy_name_[0] = "robot_0";
      enemy_name_[1] = "robot_1";
    }
    else
      ROS_ERROR("[collective_decision]color name error : %s is not a valid color name(blue and red only)",color_.c_str());

    gameStatus_sub_ = nh_.subscribe<hero_msgs::GameStatus>("/judgeSysInfo/game_state", 100,&Robot::GameStatusCallback,this);
    buffInfo_sub_ = nh_.subscribe<hero_msgs::Buffinfo>("/judgeSysInfo/buff_info", 100,&Robot::BuffInfoCallback,this);
    basic_executor_cient_[0] = nh_.serviceClient<hero_msgs::BasicExecutor>("/"+friendly_name_[0]+"/basic_executor_server");
    basic_executor_cient_[1] = nh_.serviceClient<hero_msgs::BasicExecutor>("/"+friendly_name_[1]+"/basic_executor_server");
    static_map_srv_ = nh_.serviceClient<nav_msgs::GetMap>("/static_map");
    battle_position_sub_ = nh_.subscribe<hero_msgs::BattlePosition>("/simu_decision_info/battle_position",100,&Robot::BattlePositionCallback,this);
    GetParam(&nh_);
    GetStaticMap();

    // Create tf listener
    tf_ptr_ = std::make_shared<tf::TransformListener>(ros::Duration(10));

    // Create costmap
    std::string map_path = ros::package::getPath("hero_costmap") + \
        "/config/costmap_parameter_config_for_decision.prototxt";
    costmap_ptr_ = std::make_shared<hero_costmap::CostmapInterface>(color_+"_tactic_costmap",
                                                                             *tf_ptr_,
                                                                           map_path.c_str());
  }

  bool Robot::GetStaticMap()
  {
    ros::service::waitForService("/static_map", -1);
    nav_msgs::GetMap::Request req;
    nav_msgs::GetMap::Response res;
    if(static_map_srv_.call(req,res)) {
    ROS_INFO( "[collective_decision]Received Static Map");
    map_ = res.map;
    return true;
    } else{
    ROS_ERROR ("[collective_decision]Get static map failed");
    return false;
    }
  }

  int Robot::FindClosestRobotToPosition(SideType specific_side, double x, double y)
  {
    double min_distance = 100;
    int return_val = 0;
    if(specific_side == FRIENDLY_ONLY||specific_side == BOTH_SIDE)
    {
      for(int i =0;i<2;i++)
      {
        double new_distance = hero_common::PointDistance(x,y,FindRobotPosition(friendly_name_[i]).position.x,FindRobotPosition(friendly_name_[i]).position.y);
        if(new_distance<min_distance)
        {
          return_val = i;
          min_distance = new_distance;

        }
      }
    }
    if(specific_side == ENEMY_ONLY||specific_side == BOTH_SIDE)
    {
      for(int i =0;i<2;i++)
      {
        double new_distance = hero_common::PointDistance(x,y,FindRobotPosition(enemy_name_[i]).position.x,FindRobotPosition(enemy_name_[i]).position.y);
        if(new_distance<min_distance)
        {
          return_val = i + 2;
          min_distance = new_distance;

        }
      }
    }
    return return_val;
  }

  void Robot::BattlePositionCallback(const hero_msgs::BattlePosition::ConstPtr &msg)
  {
    battle_position_ = *msg;

  }


  void Robot::GetParam(ros::NodeHandle *nh)
  {
    nh->param<double>("/RFID_F1_x", RFID_F_x[0], 7.63);
    nh->param<double>("/RFID_F1_y", RFID_F_y[0], 1.8);
    nh->param<double>("/RFID_F2_x", RFID_F_x[1], 6.23);
    nh->param<double>("/RFID_F2_y", RFID_F_y[1], 3.225);
    nh->param<double>("/RFID_F3_x", RFID_F_x[2], 4.03);
    nh->param<double>("/RFID_F3_y", RFID_F_y[2], 0.49);
    nh->param<double>("/RFID_F4_x", RFID_F_x[3], 0.45);
    nh->param<double>("/RFID_F4_y", RFID_F_y[3], 3.34);
    nh->param<double>("/RFID_F5_x", RFID_F_x[4], 1.85);
    nh->param<double>("/RFID_F5_y", RFID_F_y[4], 1.915);
    nh->param<double>("/RFID_F6_x", RFID_F_x[5], 4.05);
    nh->param<double>("/RFID_F6_y", RFID_F_y[5], 4.9);
    nh->param<double>("/RFID_height", RFID_height, 0.4);
    nh->param<double>("/RFID_width", RFID_width, 0.46);

    for(int i =0;i<6;i++)
    {
      RFID_F_x[i] = RFID_F_x[i] + RFID_width * 0.5;
      RFID_F_y[i] = RFID_F_y[i] + RFID_height * 0.5;
    }
  }


  hero_msgs::RobotPosition Robot::FindRobotPosition(std::string robot_name)
  {
    for (auto it = battle_position_.robots_position.begin(); it != battle_position_.robots_position.end(); ++it) {
      if((*it).robot_name == robot_name)
      {
        return *(it);
      }

    }
   // ROS_ERROR("no %s",robot_name.c_str());
    return hero_msgs::RobotPosition();
  }

  void Robot::GameStatusCallback(const hero_msgs::GameStatus::ConstPtr &msg)
  {
      gameStatus_ = *msg;
  }

  void Robot::BuffInfoCallback(const hero_msgs::Buffinfo::ConstPtr &msg)
  {
      buffInfo_ = *msg;
  }

  void Robot::MoveToPosition(int robot_num, double x,double y)
  {
    hero_msgs::BasicExecutor basic_executor;
    basic_executor.request.command = basic_executor.request.MOVE_TO_POSITION;
    basic_executor.request.position_x = x;
    basic_executor.request.position_y = y;

    if(basic_executor_cient_[robot_num].call(basic_executor))
    {

    }
    else {
       ROS_ERROR("[collective_decision]Failed to call basic_executor server");
    }

  }

  void Robot::AttackRobot(int robot_num, int enemy_num)
  {
    hero_msgs::BasicExecutor basic_executor;
    basic_executor.request.command = basic_executor.request.ATTACK_ROBOT;
    basic_executor.request.robot_name = enemy_name_[enemy_num];
    if(basic_executor_cient_[robot_num].call(basic_executor))
    {

    }
    else {
       ROS_ERROR("[collective_decision]Failed to call basic_executor server");
    }
  }

  void Robot::GoGetBuff(int robot_num,int buff_num)
  {
    if(robot_num>1)
    {
      ROS_ERROR("[collective_decision]friendly index must be 0 or 1! invalid index is %d",robot_num);
      return;
    }
    MoveToPosition(robot_num,RFID_F_x[buff_num],RFID_F_y[buff_num]);
  }

  void Robot::ParaUpdate()
  {
    ammo = FindRobotPosition(friendly_name_[0]).ammo;
    health = FindRobotPosition(friendly_name_[0]).health;
    combat_effectiveness = ammo * health;
  }
  int Robot::GetBuffRFIDNum(BuffType buff_type)
  {
     for(int i =0;i<6;i++)
     {
        if(buffInfo_.buff_data[i] == buffInfo_.BLUE_HEAL)
        {
          if((color_ == "blue"&&buff_type == FRIENDLY_HEAL)||(color_ == "red"&&buff_type == ENEMY_HEAL))
          {
              return i;
          }
        }
        else if(buffInfo_.buff_data[i] == buffInfo_.RED_HEAL)
        {
          if((color_ == "red"&&buff_type == FRIENDLY_HEAL)||(color_ == "blue"&&buff_type == ENEMY_HEAL))
          {
              return i;
          }
        }
        else  if(buffInfo_.buff_data[i] == buffInfo_.BLUE_RELOAD)
        {
          if((color_ == "blue"&&buff_type == FRIENDLY_AMMO)||(color_ == "red"&&buff_type == ENEMY_AMMO))
          {
              return i;
          }
        }
        else if(buffInfo_.buff_data[i] == buffInfo_.RED_RELOAD)
        {
          if((color_ == "red"&&buff_type == FRIENDLY_AMMO)||(color_ == "blue"&&buff_type == ENEMY_AMMO))
          {
              return i;
          }
        }
     }
     return -1;
  }

  void Robot::FleeBehaviour(int robot_num)
  {
    double range = 3;
    double origin_x = FindRobotPosition(friendly_name_[robot_num]).position.x;
    double origin_y = FindRobotPosition(friendly_name_[robot_num]).position.y;
    double end_x = std::min(FindRobotPosition(friendly_name_[robot_num]).position.x + range,costmap_ptr_->GetCostMap()->GetSizeXWorld());
    double end_y = std::min(FindRobotPosition(friendly_name_[robot_num]).position.y + range,costmap_ptr_->GetCostMap()->GetSizeYWorld());
    int min_cost = 100000;;
    double min_x = origin_x;
    double min_y = origin_y;
    double x = std::max(origin_x - range,0.0);
    double y = std::max(origin_y - range,0.0);
    unsigned int cell_x,cell_y;
    while(x<end_x)
    {
      while(y<end_y)
      {
        costmap_ptr_->GetCostMap()->World2Map(x,y,cell_x,cell_y);
        int new_cost = costmap_ptr_->GetCostMap()->GetCost(cell_x,cell_y) + (hero_common::PointDistance(origin_x,origin_y,x,y) * 3.0);
        if(new_cost < min_cost)
        {
          min_cost = new_cost;
          min_x = x;
          min_y = y;
        }
        y += 0.02;
      }
      x += 0.02;
      y = std::max(origin_y - range,0.0);
    }
     MoveToPosition(robot_num,min_x,min_y);
     ROS_INFO("%s flee to %f,%f",color_.c_str(),min_x,min_y);
  }


///<<< END WRITING YOUR CODE
}

///<<< BEGIN WRITING YOUR CODE FILE_UNINIT

///<<< END WRITING YOUR CODE
